import type { Express } from "express";

// Helper functions for strategy management
function generateRealStrategyCode(config: any): string {
  // Generate executable strategy code from configuration
  const { nodes, connections, name } = config;
  
  let strategyCode = `
// Generated Strategy: ${name}
// Auto-generated on: ${new Date().toISOString()}

class ${name.replace(/\s+/g, '')}Strategy {
  constructor() {
    this.name = '${name}';
    this.version = '1.0.0';
    this.indicators = [];
    this.signals = [];
  }
  
  async analyze(marketData) {
    const signals = [];
    
    // Process each node in the strategy
    ${nodes?.map((node: any) => `
    // ${node.type} Node: ${node.id}
    if (${node.type === 'indicator'}) {
      const ${node.id}_result = this.calculate${node.type}(marketData, ${JSON.stringify(node.config)});
      signals.push({ node: '${node.id}', type: '${node.type}', result: ${node.id}_result });
    }
    `).join('\n') || '// No nodes configured'}
    
    // Apply strategy logic based on connections
    const finalSignal = this.combineSignals(signals);
    
    return {
      action: finalSignal.action || 'HOLD',
      confidence: finalSignal.confidence || 50,
      reasoning: finalSignal.reasoning || 'Generated by strategy builder',
      timestamp: new Date().toISOString()
    };
  }
  
  combineSignals(signals) {
    // Basic signal combination logic
    let buySignals = 0;
    let sellSignals = 0;
    
    signals.forEach(signal => {
      if (signal.result > 0.6) buySignals++;
      else if (signal.result < 0.4) sellSignals++;
    });
    
    if (buySignals > sellSignals) {
      return { action: 'BUY', confidence: Math.min(90, 60 + buySignals * 10) };
    } else if (sellSignals > buySignals) {
      return { action: 'SELL', confidence: Math.min(90, 60 + sellSignals * 10) };
    }
    
    return { action: 'HOLD', confidence: 50 };
  }
}

module.exports = ${name.replace(/\s+/g, '')}Strategy;
`;

  return strategyCode;
}

function calculateStrategyComplexity(config: any): number {
  const nodeCount = config.nodes?.length || 0;
  const connectionCount = config.connections?.length || 0;
  const indicatorTypes = new Set(config.nodes?.map((n: any) => n.type) || []).size;
  
  return Math.min(100, (nodeCount * 2) + (connectionCount * 3) + (indicatorTypes * 5));
}

export function registerStrategyRoutes(app: Express, requireAuth: any) {
  // List available trading strategies
  app.get('/api/strategies/list', requireAuth, async (req, res) => {
    try {
      const strategies = [
        'Momentum Breakout',
        'Mean Reversion',
        'RSI Divergence',
        'Bollinger Bands Squeeze', 
        'MACD Cross',
        'Volume Profile',
        'Support Resistance',
        'Fibonacci Retracement',
        'Moving Average Cross',
        'Stochastic Oscillator'
      ];
      
      res.json({ success: true, data: strategies, timestamp: new Date().toISOString() });
    } catch (error) {
      res.status(500).json({ error: 'Failed to fetch strategies' });
    }
  });

  // Create and compile new strategy
  app.post('/api/strategies/create', requireAuth, async (req, res) => {
    try {
      const config = req.body;
      
      // Validate required fields
      if (!config.name || !config.nodes) {
        return res.status(400).json({ error: 'Strategy name and nodes are required' });
      }
      
      // Generate strategy code
      const strategyCode = generateRealStrategyCode(config);
      const complexity = calculateStrategyComplexity(config);
      
      // Create strategy record
      const strategyId = `strategy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const strategyRecord = {
        id: strategyId,
        name: config.name,
        description: config.description || `Auto-generated strategy: ${config.name}`,
        code: strategyCode,
        complexity,
        nodeCount: config.nodes.length,
        compiled: true,
        version: '1.0.0',
        createdAt: new Date().toISOString(),
        status: 'ready',
        performance: {
          backtests: 0,
          avgReturn: 0,
          winRate: 0,
          sharpeRatio: 0
        }
      };
      
      // In a real implementation, this would be stored in database
      // For now, return success response
      res.json({ 
        success: true, 
        data: strategyRecord,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Strategy creation error:', error);
      res.status(500).json({ error: 'Failed to create strategy' });
    }
  });

  // Get strategy details
  app.get('/api/strategies/:id', requireAuth, async (req, res) => {
    try {
      const strategyId = req.params.id;
      
      // Mock strategy details - in real implementation, fetch from database
      const mockStrategy = {
        id: strategyId,
        name: 'Momentum Breakout Strategy',
        description: 'Identifies momentum breakouts using multiple technical indicators',
        complexity: 75,
        nodeCount: 8,
        compiled: true,
        version: '1.0.0',
        createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
        status: 'ready',
        performance: {
          backtests: 12,
          avgReturn: 8.5,
          winRate: 65.2,
          sharpeRatio: 1.42,
          maxDrawdown: -5.8
        },
        nodes: [
          { id: 'rsi', type: 'indicator', name: 'RSI', config: { period: 14 } },
          { id: 'macd', type: 'indicator', name: 'MACD', config: { fast: 12, slow: 26, signal: 9 } },
          { id: 'volume', type: 'indicator', name: 'Volume', config: { period: 20 } },
          { id: 'signal', type: 'signal', name: 'Buy Signal', config: { threshold: 0.7 } }
        ]
      };
      
      res.json({ 
        success: true, 
        data: mockStrategy,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Strategy fetch error:', error);
      res.status(500).json({ error: 'Failed to fetch strategy details' });
    }
  });

  // Update strategy
  app.put('/api/strategies/:id', requireAuth, async (req, res) => {
    try {
      const strategyId = req.params.id;
      const updates = req.body;
      
      // In real implementation, update database record
      res.json({ 
        success: true, 
        message: 'Strategy updated successfully',
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Strategy update error:', error);
      res.status(500).json({ error: 'Failed to update strategy' });
    }
  });

  // Delete strategy
  app.delete('/api/strategies/:id', requireAuth, async (req, res) => {
    try {
      const strategyId = req.params.id;
      
      // In real implementation, delete from database
      res.json({ 
        success: true, 
        message: 'Strategy deleted successfully',
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Strategy deletion error:', error);
      res.status(500).json({ error: 'Failed to delete strategy' });
    }
  });

  // Test strategy with sample data
  app.post('/api/strategies/:id/test', requireAuth, async (req, res) => {
    try {
      const strategyId = req.params.id;
      const testData = req.body;
      
      // Mock strategy test results
      const testResults = {
        strategyId,
        testDuration: '5 minutes',
        sampleSize: 100,
        signals: [
          { timestamp: new Date().toISOString(), action: 'BUY', confidence: 85, price: 116748 },
          { timestamp: new Date(Date.now() - 300000).toISOString(), action: 'HOLD', confidence: 52, price: 116785 },
          { timestamp: new Date(Date.now() - 600000).toISOString(), action: 'SELL', confidence: 78, price: 116812 }
        ],
        performance: {
          accuracy: 73.5,
          avgConfidence: 71.7,
          signalCount: 3,
          executionTime: '245ms'
        }
      };
      
      res.json({ 
        success: true, 
        data: testResults,
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Strategy test error:', error);
      res.status(500).json({ error: 'Failed to test strategy' });
    }
  });
}